#! /usr/bin/python3
import sys
sys.path.extend( [ "../../lib", "../lib", "./lib" ] )

import traceback
from math import sqrt
from tkinter import *
from PIL import Image, ImageDraw, ImageTk

import argparse
import numpy as np

import NeuralNetwork as nn
import ModelAnalyzer as ma

import DataIO as dio
import Terminal as term

def predict( solver, solution, X, y, n ):
	x = X[n]
	y = y[n]
	yp = solver.predict( solution, np.array( [ x ] ) )[0]
	if yp != y:
		term.plot( x, art = True, label = "n:{} p:{} e:{}".format( n, yp, y ) )
		return input( "Press `Enter` to continue or `q` followed by `Enter` to quit: " ) != "q"
	return True

class DrawingPad:
	imgSize = 480
	width = 40
	def __init__( self_, **kwArgs ):
		self_._b1 = "up"
		self_._xold = None
		self_._yold = None
		self_._img = None
		self_._imgTk = None
		self_._solver = kwArgs.get( "solver", None )
		self_._solution = kwArgs.get( "solution", None )
		self_._size = kwArgs.get( "size", int( sqrt( self_._solution.theta()[0][0] ) ) if self_._solution else None )
		self_._labels = kwArgs.get( "labels", None )
		self_._repeat = kwArgs.get( "repeat", 0 )
		self_._i = 0

	def run( self_ ):
		self_._root = Tk()
		drawing_area = Canvas( self_._root, width = DrawingPad.imgSize, height = DrawingPad.imgSize, bg = 'white' )
		drawing_area.pack()
		self_._img = Image.new( "L", ( DrawingPad.imgSize, DrawingPad.imgSize ), 255 )
		drawing_area.pack()
		drawing_area.bind( "<Motion>", self_.motion )
		drawing_area.bind( "<ButtonPress-1>", self_.b1down )
		drawing_area.bind( "<ButtonRelease-1>", self_.b1up )
		drawing_area.bind( "<ButtonPress-3>", self_.b3down )
		if self_._labels:
			self_._data = { "X": [], "y": [] }
			print( "{}".format( self_.current_label() ) )

		self_._root.mainloop()

	def b1down( self_, event ):
		self_._b1 = "down"	# you only want to draw when the button is down
								# because "Motion" events happen -all the time-

	def b3down( self_, event ):
		if self_._solution:
			self_.predict()
		elif self_._labels:
			self_.make_sample()
		event.widget.delete( "all" )
		self_._img = Image.new( "L", ( DrawingPad.imgSize, DrawingPad.imgSize ), 255 )

	def b1up( self_, event ):
		self_._b1 = "up"
		self_._xold = None		   # reset the line when you let go of the button
		self_._yold = None

	def motion( self_, event ):
		if self_._b1 == "down":
			if self_._xold is not None and self_._yold is not None:
				draw = ImageDraw.Draw( self_._img )
				draw.line( [ self_._xold, self_._yold, event.x, event.y ], 0, width = DrawingPad.width )
				draw.ellipse(
					( self_._xold - DrawingPad.width / 2, self_._yold - DrawingPad.width / 2, self_._xold + DrawingPad.width / 2, self_._yold + DrawingPad.width / 2 ),
					fill = 0
				)
				draw.ellipse( ( event.x - DrawingPad.width / 2, event.y - DrawingPad.width / 2, event.x + DrawingPad.width / 2, event.y + DrawingPad.width / 2 ), fill = 0 )
				self_._imgTk = ImageTk.PhotoImage( self_._img )
				event.widget.create_image( 0, 0, anchor = "nw", image = self_._imgTk )
				event.widget.pack()
			self_._xold = event.x
			self_._yold = event.y

	def get_drawing( self_ ):
		return 255 - np.asarray( self_._img.resize( ( self_._size, self_._size ), Image.ANTIALIAS ) ).flatten()

	def predict( self_ ):
		d = self_.get_drawing()
		term.plot( d, art = True, label = "{}".format( self_._solver.predict( self_._solution, np.array( [ d ] ) )[0] ) )

	def make_sample( self_ ):
		d = self_.get_drawing()
		term.plot( d, art = True )
		self_._data["X"].append( d )
		self_._data["y"].append( self_.current_label() )
		self_._i += 1
		if self_._i >= ( len( self_._labels ) * self_._repeat ):
			self_._root.quit()
			self_._data["X"] = np.array( self_._data["X"] )
			self_._data["y"] = np.array( self_._data["y"] )
			return
		print( "{}".format( self_.current_label() ) )

	def current_label( self_ ):
		l = self_._labels[self_._i // self_._repeat]
		return l

def create( args ):
	labels = list( args.classes.split( "," ) )
	lifeDemo = DrawingPad( labels = labels, repeat = args.samples, size = args.size )
	lifeDemo.run()
	dio.save( args.data_set, lifeDemo._data )

def train( args ):
	topology = list( map( int, args.topology.split( "," ) ) )
	Lambda = list( map( float, args.Lambda.split( "," ) ) )
	solver = nn.NeuralNetworkSolver()
	rawData = dio.load( args.data_set )
	X_orig = rawData["X"]
	y_orig = rawData["y"]
	optimizationResults = ma.find_solution(
		solver, X_orig, y_orig, showFailureRateTrain = True, iters = args.iterations,
		optimizationParams = {
			"nnTopology": [topology],
			"Lambda": Lambda,
			"functions": [
			]
		}
	)
	solution = optimizationResults.solution
	dio.save( args.solution, solution )
	if args.debug:
		print( "solution = {}".format( solution ) )
	for i in range( len( y_orig ) ):
		if not predict( solver, solution, X_orig, y_orig, i ):
			return

def test( args ):
	solver = nn.NeuralNetworkSolver()
	solution = dio.load( args.solution )
	rawData = dio.load( args.data_set )
	X_orig = rawData["X"]
	y_orig = rawData["y"]
	for i in range( len( y_orig ) ):
		if not predict( solver, solution, X_orig, y_orig, i ):
			return

def show( args ):
	pass

def live( args ):
	solver = nn.NeuralNetworkSolver()
	solution = dio.load( args.solution )
	lifeDemo = DrawingPad( solver = solver, solution = solution )
	lifeDemo.run()

def main():
	parser = argparse.ArgumentParser(
		description = "NeuralNetwork experimentation tool\n\n"
		"Example invocations:\n"
		"  {0} create -l classA,classB,classC -n 30 -d train_data_ABC.p\n"
		"  {0} train -d train_data.p -s solution_ABC.p -i 100 -t 40,25 -l 1,3,10\n"
		"  {0} test -d train_data.p -s solution_ABC.p\n"
		"  {0} show -d train_data.p -z 3 -s solution_ABC.p\n"
		"  {0} live -s solution_ABC.p".format( sys.argv[0] ),
		formatter_class = argparse.RawTextHelpFormatter
	)
	subparsers = parser.add_subparsers()

	parserCreate = subparsers.add_parser( "create", help = "Prepare new batch of training samples." )
	parserCreate.add_argument( "-d", "--data-set", metavar = "path", type = str, required = True, help = "Output file for created data set." )
	parserCreate.add_argument( "-c", "--classes", metavar = "labels", type = str, required = True, help = "List of classes to be added to new data set." )
	parserCreate.add_argument( "-n", "--samples", metavar = "num", type = int, required = True, help = "Number of samples per class." )
	parserCreate.add_argument( "-r", "--size", metavar = "size", type = int, required = True, help = "Single sample resolution." )
	parserCreate.set_defaults( func = create )

	parserTrain = subparsers.add_parser( "train", help = "Train given model on given data." )
	parserTrain.add_argument( "-d", "--data-set", metavar = "path", type = str, required = True, help = "Dataset for training." )
	parserTrain.add_argument( "-s", "--solution", metavar = "path", type = str, required = True, help = "Store solution path." )
	parserTrain.add_argument( "-t", "--topology", metavar = "topo", type = str, required = True, help = "NeuralNetwork topologies to test." )
	parserTrain.add_argument( "-l", "--Lambda", metavar = "lambda", type = str, required = True, help = "Values of regularization parameter to test." )
	parserTrain.add_argument( "-i", "--iterations", metavar = "num", type = int, help = "Maximum number of iterations." )
	parserTrain.set_defaults( iterations = 50 )
	parserTrain.set_defaults( func = train )

	parserTest = subparsers.add_parser( "test", help = "Test trained model against given data." )
	parserTest.add_argument( "-d", "--data-set", metavar = "path", type = str, required = True, help = "Dataset to test a model against." )
	parserTest.add_argument( "-s", "--solution", metavar = "path", type = str, required = True, help = "Path to solution to test." )
	parserTest.set_defaults( func = test )

	parserShow = subparsers.add_parser( "show", help = "Show sample data, optionally with invalid predictions from model." )
	parserShow.add_argument( "-d", "--data-set", metavar = "path", type = str, required = True, help = "Dataset for training." )
	parserShow.add_argument( "-s", "--solution", metavar = "path", type = str, help = "Load solution path." )
	parserShow.add_argument( "-z", "--zoom", metavar = "level", type = int, help = "Zoom level." )
	parserShow.set_defaults( func = show )

	parserLive = subparsers.add_parser( "live", help = "Run live test for given solution." )
	parserLive.add_argument( "-s", "--solution", metavar = "path", type = str, required = True, help = "Solution to use for live test." )
	parserLive.set_defaults( func = live )

	parser.add_argument( "-v", "--verbose", help = "Increase program verbosity level.", action = 'store_true' )
	parser.add_argument( "-D", "--debug", help = "Print all debuging information.", action = 'store_true' )
	parser.set_defaults( verbose = False )
	parser.set_defaults( debug = False )
	args = parser.parse_args()
	args.func( args )
	return

if __name__ == "__main__":
	try:
		main()
	except Exception:
		traceback.print_exc( file = sys.stdout )
		sys.exit( 1 )

